<html>

<head>
    <title>Use-WebSQL-and-IndexedDB-in-Typescript</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">
    <link rel="stylesheet" href="prism.css"></link>
    <style>
        .columns .column {
            padding: .4rem;
        }
        #sidebar-id {
            padding: .4rem;
        }
        code {
            padding: 0;
            overflow-x: scroll;
        }
        img {
            max-width: 100%;
        }
        .off-canvas .off-canvas-sidebar
        {
            background: none;
        }
    </style>
</head>

<body>
    <div class="off-canvas off-canvas-sidebar-show">
        <a class="off-canvas-toggle btn btn-primary btn-action" href="#sidebar-id">
            <i class="icon icon-menu"></i>
        </a>
        <div id="sidebar-id" class="off-canvas-sidebar">
            <ul class="menu">
                <li class="menu-item">
                    <div class="tile tile-centered">
                        <div class="tile-icon"><img class="avatar" src="https://media.licdn.com/dms/image/C4E03AQEtgQbQGiCpUQ/profile-displayphoto-shrink_200_200/0?e=1547683200&v=beta&t=YKT1NVMDvlzVocWQtSP2Y6Z4Eoy-fqPLncAIk45nF2U"
                                alt="Avatar"></div>
                        <div class="tile-content">Yauhen Pyl</div>
                    </div>
                </li>
                <li class="divider" data-content="LINKS">
                </li>
                <li class="menu-item">
                    <a href="https://plus.google.com/+UdginPyl">Google+</a>
                </li>
                <li class="menu-item">
                    <a href="https://www.facebook.com/yauhen.pyl">Facebook</a>
                </li>
                <li class="menu-item">
                    <a href="https://pl.linkedin.com/in/eugenepyl">LinkedIn</a>
                </li>
                <li class="menu-item">
                    <a href="https://github.com/eapyl">GitHub</a>
                </li>
                <li class="menu-item">
                    <a href="mailto:gromkaktus@gmail.com">Email</a>
                </li>
            </ul>
        </div>
        <a class="off-canvas-overlay" href="#close"></a>
        <div class="off-canvas-content">
            <div class="container grid-lg">
                <h1 id="use-websql-and-indexeddb-in-typescript">Use WebSQL and IndexedDB in Typescript</h1>
<p>More information about <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDb</a> or <a href="https://www.w3.org/TR/webdatabase/">WebSQL</a>.</p>
<p>Let's define base interfaces for our task:</p>
<pre><code class="language-typescript">export interface IItem {
    id: string;
    value: string;
}

export interface IStorage&lt;T extends IItem&gt; {
    // Initial method to create storage
    init(name: string): Observable&lt;IStorage&lt;T&gt;&gt;;

    // Get the value by unique key
    get(key: string): Observable&lt;T&gt;;

    // Clear/remove all data in the storage
    clear(): Observable&lt;T&gt;;

    // Put specific value into the storage
    put(value: T): Observable&lt;T&gt;;

    // Get all values using the set of keys
    getDenseBatch(keys: string[]): Observable&lt;T&gt;;

    // Get all values from the storage
    all(): Observable&lt;T&gt;;
}
</code></pre>
<p>Here I am using <a href="http://reactivex.io/">rxjs</a> to handle results. IItem is an interface for items which we are saving, IStorage is an interface for a specific storage.</p>
<h3 id="in-memory-implementation">In Memory implementation</h3>
<p>A short example how to implement mentioned interface using in-memory array:</p>
<pre><code class="language-typescript">export class MemoryStorage&lt;T extends IItem&gt; implements IStorage&lt;T&gt; {
    private storage: { [key: string]: T } = {};

    init(name: string): Observable&lt;MemoryStorage&lt;T&gt;&gt; {
        return Observable.of(this);
    }

    get(key: string): Observable&lt;T&gt; {
        return Observable.of(this.storage[key]);
    }

    clear(): Observable&lt;T&gt; {
        this.storage = {};
        return Observable.empty&lt;T&gt;();
    }

    put(value: T): Observable&lt;T&gt; {
        if (!value.id) {
            value.id = Math.random().toString(36).substring(7);
        }
        this.storage[value.id] = value;
        return Observable.of(value);
    }

    getDenseBatch(keys: string[]): Observable&lt;T&gt; {
        return Observable.from(keys.map(x =&gt; this.storage[x]));
    }

    all(): Observable&lt;T&gt; {
        return Observable.from(Object.keys(this.storage).map(x =&gt; this.storage[x]));
    }
}
</code></pre>
<p>Simple implementation of IItem:</p>
<pre><code class="language-typescript">class TestKeyValue implements IItem {
  public id: string;
  public value: string;
}
</code></pre>
<p>Unit tests for MemoryStorage:</p>
<pre><code class="language-typescript">describe('MemoryStorage: Class', () =&gt; {
  let key1 = 'key1', key2 = 'key2';
  let value1 = 'value1', value2 = 'value2';

  function init(): MemoryStorage&lt;TestKeyValue&gt; {
    let storage = new MemoryStorage&lt;TestKeyValue&gt;();
    storage.init('test');
    return storage;
  }

  it('should create empty storage', async(() =&gt; {
    let storage = init();
    storage.all().isEmpty().subscribe(isAny =&gt; expect(isAny).toBeTruthy());
  }));

  it('should save one item', async(() =&gt; {
    let storage = init();
    storage.put({ id: key1, value: value1 });
    storage.all().isEmpty().subscribe(isAny =&gt; expect(isAny).toBeFalsy());
  }));

  it('should save/get one item', async(() =&gt; {
    let storage = init();
    let item = { id: key1, value: value1 };
    storage.put(item);
    storage.get(key1).subscribe(value =&gt; expect(value).toEqual(item));
  }));

  it('should save/get two items', async(() =&gt; {
    let storage = init();
    let items = [{ id: key1, value: value1 }, { id: key2, value: value2 }];
    storage.put(items[0]);
    storage.put(items[1]);
    let i = 0;
    storage.getDenseBatch([key1, key2]).subscribe(value =&gt; expect(value).toEqual(items[i++]));
  }));

  it('should clear saved items', async(() =&gt; {
    let storage = init();
    let items = [{ id: key1, value: value1 }, { id: key2, value: value2 }];
    storage.put(items[0]);
    storage.put(items[1]);

    storage.clear();
    storage.all().isEmpty().subscribe(isAny =&gt; expect(isAny).toBeTruthy());
  }));
});
</code></pre>
<h3 id="websql-implementation">WebSQL implementation</h3>
<p>Current implementation just just for objects where key (string) is unique string value, value (string) is a payload.</p>
<pre><code class="language-typescript">export class WebSQLStorage&lt;T extends IItem&gt; implements IStorage&lt;T&gt; {
    private db: Database;
    private databaseName: string = 'TripNoteDB';
    private name: string;

    constructor() {
        this.db = window.openDatabase(this.databaseName, '1.0', `Store information`, 40 * 1024 * 1024);
    }

    init(name: string): Observable&lt;WebSQLStorage&lt;T&gt;&gt; {
        this.name = name;
        return Observable.create((observer: Observer&lt;WebSQLStorage&lt;T&gt;&gt;) =&gt; {
            this.db.transaction(
                (tx) =&gt; tx.executeSql(`CREATE TABLE IF NOT EXISTS ${name} (key unique, value string)`,
                    [],
                    (t, results) =&gt; {
                        observer.next(this);
                        observer.complete();
                    },
                    (t, message) =&gt; {
                        observer.error(message.message.toString());
                        return true;
                    })
            );
        });
    }

    get(key: string): Observable&lt;T&gt; {
        return Observable.create((observer: Observer&lt;T&gt;) =&gt; {
            this.db.transaction((tx) =&gt; {
                tx.executeSql(`SELECT * FROM ${this.name} WHERE key='${key}'`, [],
                    (t, results) =&gt; {
                        let len = results.rows.length;
                        if (len === 0) {
                            observer.next(undefined);
                        } else if (len === 1) {
                            observer.next(results.rows.item(0));
                        } else {
                            observer.error('There should be no more than one entry');
                        }
                        observer.complete();
                    },
                    (t, message) =&gt; {
                        observer.error(message.message.toString());
                        return true;
                    });
            });
        });
    }

    clear() {
        return Observable.create((observer: Observer&lt;T&gt;) =&gt; {
            this.db.transaction((tx) =&gt; {
                tx.executeSql(`DELETE FROM ${this.name}`, [], (t, r) =&gt; observer.complete(), (t, e) =&gt; {
                    observer.error(e.message.toString());
                    return true;
                });
            });
        });
    }

    all(): Observable&lt;T&gt; {
        return Observable.create((observer: Observer&lt;T&gt;) =&gt; {
            this.db.transaction((tx) =&gt; {
                tx.executeSql(`SELECT * FROM ${this.name}`,
                    [],
                    (t, results) =&gt; {
                        for (let i = 0; i &lt; results.rows.length; i++) {
                            observer.next(results.rows.item(i));
                        }
                        observer.complete();
                    },
                    (t, message) =&gt; {
                        observer.error(message.message.toString());
                        return true;
                    });
            });
        });
    }

    put(value: T): Observable&lt;T&gt; {
        return Observable.create((observer: Observer&lt;T&gt;) =&gt; {
            this.db.transaction((tx) =&gt; {
                tx.executeSql(`INSERT OR REPLACE INTO ${this.name} VALUES (?, ?)`, [value.id, value.value],
                    () =&gt; {
                        observer.next(value);
                        observer.complete();
                    },
                    (t, e) =&gt; {
                        observer.error(e.message.toString());
                        return true;
                    });
            });
        });
    }

    getDenseBatch(keys: string[]): Observable&lt;T&gt; {
        if (keys.length === 0) {
            return Observable.empty&lt;T&gt;();
        };

        return Observable.create((observer: Observer&lt;T[]&gt;) =&gt; {
            this.db.transaction((tx) =&gt; {
                let key = keys.map(x =&gt; '\'' + x + '\'').join(',');
                tx.executeSql(`SELECT * FROM ${this.name} WHERE key IN (${key})`,
                    [],
                    (t, results) =&gt; {
                        for (let i = 0; i &lt; results.rows.length; i++) {
                            observer.next(results.rows.item(i));
                        }
                        observer.complete();
                    },
                    (t, e) =&gt; {
                        observer.error(e.message.toString());
                        return true;
                    });
            });
        });
    }
}
</code></pre>
<pre><code class="language-typescript">describe('WebSQLStorage: Class', () =&gt; {
  let key1 = 'key1', key2 = 'key2';
  let value1 = 'value1', value2 = 'value2';

  it('should create empty storage', async(() =&gt; {
    let storage = new WebSQLStorage&lt;TestKeyValue&gt;();
    storage.init('test1').subscribe(() =&gt; {
      storage.all().isEmpty().subscribe(isAny =&gt; expect(isAny).toBeTruthy());
    });
  }));

  it('should save one item ', async(() =&gt; {
    let storage = new WebSQLStorage&lt;TestKeyValue&gt;();
    storage.init('test2').subscribe(() =&gt; {
      storage.put({ id: key1, value: value1 }).subscribe(() =&gt; {
        storage.all().isEmpty().subscribe(isAny =&gt; expect(isAny).toBeFalsy());
      });
    });
  }));

  it('should save/get one item', async(() =&gt; {
    let storage = new WebSQLStorage&lt;TestKeyValue&gt;();
    storage.init('test3').subscribe(() =&gt; {
      let item = { id: key1, value: value1 };
      storage.put(item).subscribe(() =&gt; {
        storage.get(key1).subscribe(value =&gt; {
          expect(value.value).toEqual(item.value);
        });

      });
    });
  }));

  it('should save/get two items', async(() =&gt; {
    let storage = new WebSQLStorage&lt;TestKeyValue&gt;();
    storage.init('test4').subscribe(() =&gt; {
      let items = [{ id: key1, value: value1 }, { id: key2, value: value2 }];
      storage.put(items[0])
      .subscribe(() =&gt; storage.put(items[1])
        .subscribe(() =&gt; {
          let i = 0;
          storage.getDenseBatch([key1, key2])
            .subscribe(value =&gt; expect(value.value).toEqual(items[i++].value));
        }));
    });
  }));

  it('should clear saved items', async(() =&gt; {
    let storage = new WebSQLStorage&lt;TestKeyValue&gt;();
    storage.init('test5').subscribe(() =&gt; {
      let items = [{ id: key1, value: value1 }, { id: key2, value: value2 }];
      storage.put(items[0])
        .zip(() =&gt; storage.put(items[1]))
        .subscribe(() =&gt; storage.clear()
        .subscribe(() =&gt; {
          storage.all().isEmpty().subscribe(isAny =&gt; expect(isAny).toBeTruthy());
        }));
    });
  }));
});
</code></pre>
<h3 id="indexeddb-implementation">IndexedDB implementation</h3>
<p>How to use IndexedDB is <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB">here</a>.
There are very useful <a href="https://www.codeproject.com/articles/744986/how-to-do-some-magic-with-indexeddb">tricks</a>.</p>
<pre><code class="language-typescript">export class IndexedDBStorage&lt;T extends IItem&gt; implements IStorage&lt;T&gt; {
    private databaseName: string = 'TripNoteDB';
    private name: string;

    private getDb(version?: number, storeName?: string): Observable&lt;IDBDatabase&gt; {
        return Observable.create((observer: Observer&lt;number&gt;) =&gt; {
            let req = version &amp;&amp; version &gt; 0 ? window.indexedDB.open(this.databaseName, version)
                : window.indexedDB.open(this.databaseName);
            req.onsuccess = (e) =&gt; {
                let db = (&lt;any&gt;event.target).result;
                observer.next(db);
                db.close();
                observer.complete();
            };
            req.onupgradeneeded = (e) =&gt; {
                let db = (&lt;any&gt;e.target).result;
                if (storeName &amp;&amp; !db.objectStoreNames.contains(storeName)) {
                    db.createObjectStore(storeName, { keyPath: 'id' });
                    let transaction = (&lt;any&gt;e.target).transaction;
                    transaction.oncomplete = (event) =&gt; {
                        observer.next(db);
                        db.close();
                        observer.complete();
                    };
                };
            };
            req.onblocked = (event) =&gt; observer.error('IndexedDB is blocked');
            req.onerror = (e) =&gt; observer.error(e.error);
        });
    }

    private getVersionOfDb(name: string): Observable&lt;number&gt; {
        return this.getDb().map(db =&gt; {
            if (!db.objectStoreNames.contains(this.name)) {
                return db.version + 1;
            } else {
                return db.version;
            }
        });
    }

    init(name: string): Observable&lt;IndexedDBStorage&lt;T&gt;&gt; {
        this.name = name;
        return Observable.create((observer: Observer&lt;IndexedDBStorage&lt;T&gt;&gt;) =&gt; {
            this.getVersionOfDb(name).subscribe((version) =&gt; {
                this.getDb(version, name).subscribe(db =&gt; {
                    observer.next(this);
                    observer.complete();
                });
            });
        });
    }

    all(): Observable&lt;T&gt; {
        return Observable.create((observer: Observer&lt;T&gt;) =&gt; {
            this.getDb().subscribe(db =&gt; {
                let req = db.transaction(this.name, 'readwrite').objectStore(this.name)
                    .openCursor();
                req.onsuccess = (e) =&gt; {
                    let res = (&lt;any&gt;event.target).result;
                    if (res) {
                        observer.next(res.value);
                        res.continue();
                    }
                    observer.complete();
                };
                req.onerror = (e) =&gt; observer.error(e.error);
            });
        });
    }

    get(key: string): Observable&lt;T&gt; {
        return Observable.create((observer: Observer&lt;T&gt;) =&gt; {
            this.getDb().subscribe(db =&gt; {
                let req = db.transaction(this.name).objectStore(this.name).get(key);
                req.onerror = (e) =&gt; observer.error(e.error);
                req.onsuccess = (e) =&gt; {
                    observer.next(req.result);
                    observer.complete();
                };
            });
        });
    }

    clear(): Observable&lt;IStorage&lt;T&gt;&gt; {
        return Observable.create((observer: Observer&lt;IStorage&lt;T&gt;&gt;) =&gt; {
            this.getDb().subscribe(db =&gt; {
                let req = db.transaction(this.name, 'readwrite').objectStore(this.name).clear();
                req.onerror = (e) =&gt; observer.error(e.error);
                req.onsuccess = (e) =&gt; {
                    observer.next(this);
                    observer.complete();
                };
            });
        });
    }

    put(value: T): Observable&lt;T&gt; {
        return Observable.create((observer: Observer&lt;T&gt;) =&gt; {
            this.getDb().subscribe(db =&gt; {
                let req = db.transaction(this.name, 'readwrite').objectStore(this.name).put(value);
                req.onerror = (e) =&gt; {
                    observer.error(e.error);
                };
                req.onsuccess = (e) =&gt; {
                    observer.next(value);
                    observer.complete();
                };
            });
        });
    }

    getDenseBatch(keys: string[]): Observable&lt;T&gt; {
        return Observable.create((observer: Observer&lt;T&gt;) =&gt; {
            this.getDb().subscribe(db =&gt; {
                let set = keys.sort();
                let i = 0;
                let req = db.transaction(this.name).objectStore(this.name)
                    .openCursor();
                req.onsuccess = (e) =&gt; {
                    let cursor = (&lt;any&gt;event.target).result;
                    if (!cursor) { observer.complete(); return; }
                    let key = cursor.key;
                    while (key &gt; set[i]) {
                        // The cursor has passed beyond this key. Check next.
                        ++i;
                        if (i === set.length) {
                            // There is no next. Stop searching.
                            observer.complete();
                            return;
                        }
                    }
                    if (key === set[i]) {
                        // The current cursor value should be included and we should continue
                        // a single step in case next item has the same key or possibly our
                        // next key in set.
                        observer.next(cursor.value);
                        cursor.continue();
                    } else {
                        // cursor.key not yet at set[i]. Forward cursor to the next key to hunt for.
                        cursor.continue(set[i]);
                    }
                };
                req.onerror = (e) =&gt; observer.error(e.error);
            });
        });
    }
}
</code></pre>
<p>Unit tests for indexedDB:</p>
<pre><code class="language-typescript">describe('IndexedDBStorage: Class', () =&gt; {
  let key1 = 'key1', key2 = 'key2';
  let value1 = 'value1', value2 = 'value2';

  it('should create empty storage', (done) =&gt; {
    let storage = new IndexedDBStorage&lt;TestKeyValue&gt;();
    storage.init('test1').subscribe(() =&gt; {
      storage.all().isEmpty().subscribe(isAny =&gt; {
        expect(isAny).toBeTruthy();
        done();
      });
    });
  });

  it('should save one item ', (done) =&gt; {
    let storage = new IndexedDBStorage&lt;TestKeyValue&gt;();
    storage.init('test2').subscribe(() =&gt; {
      storage.put({ id: key1, value: value1 }).subscribe(() =&gt; {
        storage.all().isEmpty().subscribe(isAny =&gt; {
          expect(isAny).toBeFalsy();
          done();
        });
      });
    });
  });

  it('should save/get one item', (done) =&gt; {
    let storage = new IndexedDBStorage&lt;TestKeyValue&gt;();
    storage.init('test3').subscribe(() =&gt; {
      let item = { id: key1, value: value1 };
      storage.put(item).subscribe(() =&gt; {
        storage.get(key1).subscribe(value =&gt; {
          expect(value).toEqual(item);
          done();
        });
      });
    });
  });

  it('should save/get two items', (done) =&gt; {
    let storage = new IndexedDBStorage&lt;TestKeyValue&gt;();
    storage.init('test4').subscribe(() =&gt; {
      let items = [{ id: key1, value: value1 }, { id: key2, value: value2 }];
      let item1 = storage.put(items[0])
        .merge(storage.put(items[1])).last()
        .subscribe(y =&gt; {
          storage.getDenseBatch([key1, key2]).toArray().subscribe(x =&gt; {
            expect(x[0]).toEqual(items[0]);
            expect(x[1]).toEqual(items[1]);
            done();
          });
        });
      });
  });

  it('should clear saved items', (done) =&gt; {
    let storage = new IndexedDBStorage&lt;TestKeyValue&gt;();
    storage.init('test5').subscribe(() =&gt; {
      let items = [{ id: key1, value: value1 }, { id: key2, value: value2 }];
      storage.put(items[0])
        .merge(storage.put(items[1])).last()
        .subscribe(x =&gt; storage.clear()
          .subscribe(y =&gt; storage.all().isEmpty().subscribe(isAny =&gt; {
              expect(isAny).toBeTruthy();
              done();
            })));
    });
  });
});
</code></pre>

                <div class="sharethis-inline-share-buttons"></div>
                <div id="disqus_thread"></div>
                <script>
                    (function() { // DON'T EDIT BELOW THIS LINE
                        var d = document,
                            s = d.createElement('script');
                        s.src = '//eapyl-github-io.disqus.com/embed.js';
                        s.setAttribute('data-timestamp', +new Date());
                        (d.head || d.body).appendChild(s);
                    })();
                </script>
            </div>
        </div>
    </div>
    <script async src="prism.js"></script>
    <script>
        (function (i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date(); a = s.createElement(o),
                m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
        })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
    
        ga('create', 'UA-87583712-1', 'auto');
        ga('send', 'pageview');
    </script>
    <script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5906f3ca75e4e1001109c19a&product=inline-share-buttons"></script>
</body>

</html>